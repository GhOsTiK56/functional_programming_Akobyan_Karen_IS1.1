# Функциональное Программирование Акобян Карен ИС-1, подгруппа-1

## Отчет

### Список задач
1. Climbing Stairs
2. Jump Game II
3. Pascal's Triangle II
4. Best Time to Buy and Sell Stock I
5. Best Time to Buy and Sell Stock II

### 1 Задача Climbing Stairs
Код: 
```python
from functools import lru_cache

class Solution:
    def climbStairs(self, n: int) -> int:

        @lru_cache(None)  # мемоизация
        def dp(i):
            if i <= 2:
                return i
            return dp(i - 1) + dp(i - 2)

        return dp(n)
```
Импортируем декоратор lru_cache, он хранит результаты вызовов функции для заданных аргументов, чтобы при повторном вызове не пересчитывать подзадачу.
В динамическом программировании это и есть мемоизация.

@lru_cache(None) - декоратор, который кэширует все вызовы функции. "None" - обозначает, что кэш не ограничен по размеру. Это нужно чтобы рекурсивное решение не было столь медлительно, потому что без мемоизации нам нужно было бы на каждом шагу вычислять одно и то же значения "dp(k)"

## Методология решения: 
Определяем рекурсивную функцию dp(i)

Создаём функцию, которая принимает число ступеней i и возвращает количество способов добраться до этой ступени.

Задаём базовые случаи

Определяем условия, при которых функция возвращает готовый результат без рекурсивных вызовов:
    Если i == 1, возвращаем 1, так как есть только один способ подняться на одну ступень.
    Если i == 2, возвращаем 2, так как есть два способа: два шага по одной ступени или один шаг на две ступени.

Рекурсивный расчёт для всех остальных ступеней: 

Для всех i > 2 вычисляем результат как сумму количества способов для двух предыдущих ступеней: dp(i) = dp(i-1) + dp(i-2)

Здесь мы используем результаты подзадач: количество способов для i-1 и i-2 ступеней.

После определения рекурсивной функции вызываем её с аргументом n: dp(n).

Результат вызова функции будет содержать количество всех возможных способов подняться на n ступеней.


## 2 Задача Jump Game II
Код: 
```python
class Solution:
    def jump(nums: list[int]) -> int:
        n = len(nums)

        def dfs(level_start, level_end, jumps):
            if level_end >= n - 1:
                return jumps  # достигли конца

            # находим максимально дальнюю позицию на следующем уровне
            farthest = max(i + nums[i] for i in range(level_start, level_end + 1))
            return dfs(level_end + 1, farthest, jumps + 1)

        # начинаем с уровня, включающего только первую позицию
        return dfs(0, 0, 0)
```
## Методология решения: 
Определяем рекурсивную функцию dfs(level_start, level_end, jumps):
    level_start и level_end — границы текущего уровня прыжка.
    jumps — количество уже совершённых прыжков.

Базовый случай: 
    Если level_end >= n-1, возвращаем jumps — достигли конца массива.

Рекурсивный расчёт для следующего уровня: 
    Вычисляем farthest = max(i + nums[i] for i in range(level_start, level_end + 1)) — максимальную позицию, которую можно достичь за один прыжок с текущего уровня.

Рекурсивно вызываем dfs(level_end + 1, farthest, jumps + 1) для следующего уровня.Начинаем рекурсию

Первый уровень содержит только первую позицию: dfs(0, 0, 0).


## 3 Задача Pascal's Triangle II
Код: 
```python
class Solution:
    def getRow(rowIndex: int) -> list[int]:
        # рекурсивная функция возвращает строку треугольника Паскаля
        def build_row(n):
            if n == 0:
                return [1]
            prev_row = build_row(n - 1)  # рекурсивно получаем предыдущую строку
            row = [1]
            # вычисляем элементы текущей строки через предыдущую
            for i in range(1, len(prev_row)):
                row.append(prev_row[i - 1] + prev_row[i])
            row.append(1)
            return row

        return build_row(rowIndex)
```

## Методология решения: 
Определяем рекурсивную функцию build_row(n)

Принимает индекс строки n и возвращает список элементов этой строки треугольника Паскаля.

Задаём базовый случай: 
    Если n == 0, возвращаем [1] - первая строка треугольника.

Рекурсивный расчёт для остальных строк:

Вызываем prev_row = build_row(n - 1) - получаем предыдущую строку.
    Создаём новую строку row, начинаем с [1].
    Для всех индексов от 1 до len(prev_row)-1 вычисляем элемент как сумму двух элементов предыдущей строки:
        row[i] = prev_row[i-1] + prev_row[i]

Добавляем 1 в конец строки, возвращаем строку row.

Вызываем build_row(rowIndex), чтобы получить нужную строку треугольника Паскаля.


## 4 Задача Best Time to Buy and Sell Stock I
Код:
```python
class Solution:
    def maxProfit(prices: list[int]) -> int:

        def helper(i, min_price, max_profit):
            if i == len(prices):
                return max_profit
            # обновляем минимальную цену
            min_price = min(min_price, prices[i])
            # обновляем максимальную прибыль
            max_profit = max(max_profit, prices[i] - min_price)
            # рекурсивный вызов хвостовой рекурсии
            return helper(i + 1, min_price, max_profit)

        return helper(0, float('inf'), 0)
```
## Методология решения: 
Определяем рекурсивную функцию helper(i, min_price, max_profit)
    i — текущий день в массиве цен
    min_price — минимальная цена акции, встреченная до текущего дня
    max_profit — максимальная прибыль, найденная до текущего дня

Базовый случай рекурсии: 
    Если i == n (конец массива цен), возвращаем max_profit — это максимальная прибыль, которую можно получить за весь период.

Рекурсивный расчёт на каждом шаге:
    Обновляем минимальную цену акции до текущего дня:
    min_price = min(min_price, prices[i])

    Вычисляем потенциальную прибыль, если продать акцию в текущий день:
    profit_today = prices[i] - min_price

    Обновляем максимальную прибыль, если текущая прибыль больше предыдущей:
    max_profit = max(max_profit, profit_today)

    Рекурсивно вызываем функцию для следующего дня:
    return helper(i + 1, min_price, max_profit)

Инициализация рекурсии
    Начинаем с первого дня массива, минимальная цена = бесконечность, максимальная прибыль = 0:
    helper(0, float('inf'), 0)

Результат:
    Возвращается максимальная прибыль за весь период, которая учитывает одну покупку и одну продажу.


## 5 Задача Best Time to Buy and Sell Stock II
Код:
```python
from functools import lru_cache

class Solution:
    def maxProfit(prices: list[int]) -> int:

        n = len(prices)

        @lru_cache(None)
        def dp(i, holding):
            if i == n:
                return 0
            if holding:
                return max(prices[i] + dp(i + 1, False), dp(i + 1, True))
            else:
                return max(-prices[i] + dp(i + 1, True), dp(i + 1, False))

        return dp(0, False)
```

## Методология решения: 
Определяем рекурсивную функцию dp(i, holding)
    i — текущий день (индекс в массиве prices)
    holding — булев флаг, показывающий, держим ли мы акцию в текущий день (True — держим, False — нет)

Базовый случай рекурсии:
    Если достигнут конец массива (i == n), возвращаем 0 — больше нет дней для совершения сделок, прибыль равна нулю.

Рекурсивный расчёт для состояния holding: 
    Если мы держим акцию:
        Продать акцию сегодня: прибыль = prices[i] + dp(i + 1, False)
        Держать акцию и не продавать: прибыль = dp(i + 1, True)
        Выбираем максимум из этих двух вариантов:
            max(prices[i] + dp(i + 1, False), dp(i + 1, True))

Рекурсивный расчёт для состояния not holding:
    Если мы не держим акцию:
        Купить акцию сегодня: прибыль = -prices[i] + dp(i + 1, True)
        Пропустить день и не покупать: прибыль = dp(i + 1, False)
        Выбираем максимум:
            max(-prices[i] + dp(i + 1, True), dp(i + 1, False))

Начинаем с первого дня без акции: dp(0, False)
Возвращаем значение функции — максимальную прибыль за весь период.


## Контрольные вопросы: 

## 1. Динамическое программирование (DP)
Динамическое программирование - это метод решения задач, при котором сложная задача разбивается на более простые подзадачи, результаты которых запоминаются для повторного использования. Основная цель DP - избежать повторных вычислений одних и тех же подзадач, что позволяет существенно сократить время выполнения алгоритма по сравнению с наивной рекурсией. DP особенно полезно в задачах, где решение можно выразить через рекуррентные соотношения между подзадачами.

DP применяется в двух основных формах:

    Снизу вверх (итеративно, tabulation) - сначала решаются самые маленькие подзадачи, и их результаты используются для вычисления более крупных подзадач.

    Сверху вниз (рекурсивно с мемоизацией) - вычисляем решение задачи рекурсивно, сохраняя результаты подзадач в памяти, чтобы при повторных вызовах использовать уже вычисленные значения.

## 2. Big O (O-нотация)
Big O — это математическая нотация, которая описывает асимптотическую сложность алгоритма, то есть, как время выполнения или использование памяти алгоритма растет с увеличением размера входных данных.
    O(1) — константное время: время выполнения не зависит от размера входных данных.
    O(n) — линейное время: время выполнения растет пропорционально размеру входа.
    O(n²) — квадратичное время: время выполнения растет пропорционально квадрату размера входа.

Big O используется для оценки эффективности алгоритма, позволяя понять, насколько алгоритм масштабируем при увеличении объема данных. Это особенно важно при выборе между рекурсивными и итеративными подходами, а также при использовании DP, где без оптимизации сложность может быть экспоненциальной, а с мемоизацией — линейной или квадратичной.

## 3. Мемоизация в рекурсии
Мемоизация — это техника, при которой результаты вычисленных рекурсивных вызовов сохраняются в памяти и повторно используются при необходимости, вместо того чтобы пересчитывать их заново.

Применение мемоизации позволяет:
    Сократить количество вычислений: каждая уникальная подзадача вычисляется только один раз.
    Оптимизировать рекурсивные алгоритмы, которые без мемоизации имеют экспоненциальную сложность.
    Объединять преимущества рекурсии и DP: рекурсия обеспечивает удобное разбиение задачи на подзадачи, а мемоизация предотвращает повторное вычисление.

Мемоизация обычно реализуется с помощью словарей или встроенных декораторов (@lru_cache в Python), что позволяет легко интегрировать её в рекурсивные решения.
